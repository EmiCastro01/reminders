use clap::{Parser, Subcommand};
use chrono::NaiveDate;
use serde::{Serialize, Deserialize};
use std::fs;
use std::io;
//use notify_rust::Notification;
const CLI_TOP_BORDER: &str = "┌───────────────────────────────────────────────────┐\n|                      Reminders                    |\n└ - - - - - - - - - - - - - - - - - - - - - - - - - ┘ \n\n";
const CLI_BOTTOM_BORDER: &str = "\n\n└───────────────────────────────────────────────────┘";

const REMINDERS_FILE_PATH: &str = "reminders.json";
// ---- Reminder structure ----- 
#[derive(Serialize, Deserialize, Debug)]
struct Reminder {
    name: String,
    description: String,
    date: String,
}
#[derive(PartialEq, Debug)]
enum STATUS {
    Good,
    AutoGenerated,
    EmptyField,
    InvalidDate,
    Error,
    Warning,
}

fn load_reminders() -> Vec<Reminder> {
    let data = fs::read_to_string(REMINDERS_FILE_PATH).unwrap_or_else(|_| "[]".to_string());
    serde_json::from_str(&data).unwrap_or_else(|_| Vec::new())

}
// ---CLI display struct ----- 
struct CliDsp {
    steps: i8,
    current_step: i8,
    field_buffer: Vec<String>,
    content_dsp: fn(i8),
    content_input: Option<fn(&mut Vec<String>, i8) -> STATUS>,
    validator: Option<fn(STATUS, &mut i8) -> STATUS>,
    callback: Option<fn(&Vec<String>)>,
}
 
// --- Funciones para CliDsp ---- 
//
// Validator:
fn validator(status: STATUS, current_step: &mut i8) -> STATUS {


    match status {
        STATUS::Good => {
            *current_step += 1;
            return STATUS::Good;
        },
        STATUS::AutoGenerated => {
            println!("Warnin: Auto-generated field");
            *current_step += 1;
            return STATUS::Warning;
        },
        STATUS::EmptyField => {
            println!("Error: This field cannot be empty.");
            return STATUS::Error;
        },
        STATUS::InvalidDate => {
            println!("Error: Invalid date format. Please enter the date in YYYY-MM-DD format.");
            return STATUS::Error;
        },
        _ => {
            println!("An unexpected error occurred.");
            return STATUS::Error;
        }

    }
}
// Add Reminder:
fn content_dsp_add_reminder(current_step: i8) {
    println!("Add Reminder");
        match current_step {
            0 => println!("Enter the name of the reminder:"),
            1 => println!("Enter an Alert Message:"),
            2 => println!("Enter the date of the reminder (YYYY-MM-DD):"),
            _ => println!("Invalid step"),
        }
}

fn content_input_add_reminder(field_buffer: &mut Vec<String>, current_step: i8) -> STATUS {
    let mut buffer = String::new();
    std::io::stdin().read_line(&mut buffer).expect("Failed to read line");
    let input = buffer.trim().to_string();


        match current_step {
            0 => {
             if input.is_empty() {
                return STATUS::EmptyField;
             } else {
                field_buffer.push(input);
                return STATUS::Good;
             }
            }
            1 => {
                if input.is_empty() {
                    field_buffer.push("-".to_string());
                    return STATUS::AutoGenerated;
                } else {
                    field_buffer.push(input);
                    return STATUS::Good;
                }
            }
            2 => {
                match NaiveDate::parse_from_str(&input, "%Y-%m-%d") {
                    Ok(_) => {
                        field_buffer.push(input);
                        return STATUS::Good;
                    },
                    Err(_) => {
                        return STATUS::InvalidDate;
                    }
                }
            }
            _ => {
                return STATUS::Error;
            }
        }
 }

fn callback_add_reminder(field_buffer: &Vec<String>) {
    
    println!("Saving reminder...");
    let reminder = Reminder {
        name: field_buffer[0].clone(),
        description: field_buffer[1].clone(),
        date: field_buffer[2].clone(),
    };

    let mut reminders = load_reminders();
    reminders.push(reminder);
    let data = serde_json::to_string_pretty(&reminders).expect("Failed to serialize reminders");
    fs::write(REMINDERS_FILE_PATH, data).expect("Failed to write reminders to file");

    println!("Reminder saved successfully!");
}

// ----- Show Reminders ----- 
fn content_dsp_show_reminders(_current_step: i8) {
    println!("       Rm |    Name            | Date       ");
    println!("       ---------------------------------------");
    let reminders = load_reminders();
    if reminders.is_empty() {
        println!("Nothing here!.");
    } else {
        for (index, reminder) in reminders.iter().enumerate() {
            println!("       {:<2} | {:<18} | {:<10}",index+1, reminder.name, reminder.date);
        }
    }
}



#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    Add,
    Show,
    Rm { nombre: Option<String>,
        #[arg(long)]
        all: bool,
    },
    Edit { nombre: String},

}

fn cli_clear_screen() {
    // Clear the screen using ANSI escape codes
    print!("\x1B[2J\x1B[1;1H");
}
fn display(feature: &mut CliDsp) {
    let mut status_dsp = STATUS::Good;         // Good by default.
    while feature.current_step < feature.steps {
        if status_dsp == STATUS::Good || status_dsp == STATUS::AutoGenerated {
            cli_clear_screen();
            println!("{}", CLI_TOP_BORDER);
        }
        (feature.content_dsp)(feature.current_step);
        println!("{}", CLI_BOTTOM_BORDER);
        if let Some(input_fn) = feature.content_input {
            if let Some(validator_fn) = feature.validator {
                status_dsp = (validator_fn)(input_fn(&mut feature.field_buffer, feature.current_step), &mut feature.current_step);
            }    
        } else {
            feature.current_step += 1; // If no input is needed, just move to the next step.
        }

    }
    if let Some(callback_fn) = feature.callback {                           // Just if needed a
                                                                            // final callback.
        callback_fn(&feature.field_buffer);
    }                                                                       
 }

fn main() {
    let cli = Cli::parse();

    match &cli.command {
        Some(Commands::Add) => {
            let mut add_reminder_dsp = CliDsp {
                steps: 3,
                current_step: 0,
                field_buffer: Vec::new(),
                content_dsp: content_dsp_add_reminder,
                content_input: Some(content_input_add_reminder),
                validator: Some(validator),
                callback: Some(callback_add_reminder),
            };
            display(&mut add_reminder_dsp);
                        // Aquí puedes agregar la lógica para agregar una tarea
        }
        Some(Commands::Show) => {
            let mut show_reminders_dsp = CliDsp {
                steps: 1,
                current_step: 0,
                field_buffer: Vec::new(),
                content_dsp: content_dsp_show_reminders,
                content_input: None,
                validator: None,
                callback: None,
            };
            display(&mut show_reminders_dsp);
        }
        Some(Commands::Rm { nombre, all }) => {
            if *all {
                println!("Eliminando todas las tareas...");
                // Aquí puedes agregar la lógica para eliminar todas las tareas
            } else if let Some(nombre) = nombre {
                println!("Eliminando tarea: {}", nombre);
                // Aquí puedes agregar la lógica para eliminar una tarea específica
            } else {
                println!("Por favor, especifica el nombre de la tarea o usa --all para eliminar todas las tareas.");
            }
        }
        Some(Commands::Edit { nombre }) => {
            println!("Editando tarea: {}", nombre);
            // Aquí puedes agregar la lógica para editar una tarea específica
        }
        None => {
            println!("No se ha especificado ningún comando. Usa --help para ver las opciones disponibles.");
        }
    }
   }
