use clap::{Parser, Subcommand};
use chrono::{NaiveDate,Local, Duration};
use serde::{Serialize, Deserialize};
use std::fs;
use std::io;
use std::env;
use std::path::PathBuf;
use notify_rust::Notification;
const CLI_TOP_BORDER: &str = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n|                      Reminders                    |\nâ”” - - - - - - - - - - - - - - - - - - - - - - - - - â”˜ \n\n";
const CLI_BOTTOM_BORDER: &str = "\n\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜";
// ------------ FILEPATH STUFF ------------------------------
const REMINDERS_FILE_PATH: &str = ".local/share/reminders.json";

fn get_file_path() -> String {
    if let Ok(home) = env::var("HOME"){
        let mut path = PathBuf::from(home);
        path.push(REMINDERS_FILE_PATH);
        return path.to_string_lossy().into_owned();
    }
    return REMINDERS_FILE_PATH.to_string();

}

// ---------- notifications & daemon ------------------

fn run_check() {
   let reminders = load_reminders();
   let today = Local::now().naive_local().date();
   let tomorrow = today + Duration::days(1);
   let mut today_rems: Vec<Reminder> = Vec::new();
   let mut tomorrow_rems: Vec<Reminder> = Vec::new();
   let mut breaker: bool = true; // for avoiding jump to notify if no tasks for today or tomorrow.
   for rem in reminders {
    
       if let Ok(rem_date) = NaiveDate::parse_from_str(&rem.date, "%Y-%m-%d") {
            if rem_date == today{
                today_rems.push(rem.clone());
                breaker = false;
            }
       }

       if let Ok(rem_date) = NaiveDate::parse_from_str(&rem.date, "%Y-%m-%d") {
           if rem_date == tomorrow{
                tomorrow_rems.push(rem.clone());
                breaker = false;
           }
       }
   }
   if breaker {
       return;
   }
   notify(&mut today_rems, &mut tomorrow_rems)
}

fn notify(today_rems: &mut Vec<Reminder>,tomorrow_rems: &mut Vec<Reminder>) {
    if !today_rems.is_empty() && tomorrow_rems.is_empty(){
        let mut today_rems_as_string = String::new();
        
        for rem in today_rems {
            today_rems_as_string.push_str(&rem.name);
            today_rems_as_string.push_str(", ");
        }
        today_rems_as_string.truncate(today_rems_as_string.len().saturating_sub(2));
    Notification::new()
        .summary("â° Heyyy!! You have some stuff today")
        .body(&format!("TODO today: {}", today_rems_as_string))
        .show()
        .unwrap();
    }
    else if !tomorrow_rems.is_empty() && today_rems.is_empty() {

        let mut tomorrow_rems_as_string = String::new();
        for rem in tomorrow_rems {
            tomorrow_rems_as_string.push_str(&rem.name);
            tomorrow_rems_as_string.push_str(", ");
        }

        tomorrow_rems_as_string.truncate(tomorrow_rems_as_string.len().saturating_sub(2));

        Notification::new()
            .summary("ðŸ”œ Get ready for Tomorrowwwww..")
            .body(&format!("TODO tomorrow: {}", tomorrow_rems_as_string))
            .show()
            .unwrap();
    }
    else if !tomorrow_rems.is_empty() && !today_rems.is_empty() { 

        let mut tomorrow_rems_as_string = String::new();
        let mut today_rems_as_string = String::new();

        for rem in today_rems {
            today_rems_as_string.push_str(&rem.name);
            today_rems_as_string.push_str(", ");
        }
        for rem in tomorrow_rems {
            tomorrow_rems_as_string.push_str(&rem.name);
            tomorrow_rems_as_string.push_str(", ");
        }
        Notification::new()
            .summary("Seems you're busy.. ðŸ˜ª")
            .body(&format!("Check this..:\nFor Today: {}\nFor Tomorrow: {}", today_rems_as_string, tomorrow_rems_as_string))
            .show()
            .unwrap();
    }


}
// ---- Reminder structure ----- 
#[derive(Clone, Serialize, Deserialize, Debug)]
struct Reminder {
    name: String,
    description: String,
    date: String,
}
#[derive(PartialEq, Debug)]
enum STATUS {
    Good,
    AutoGenerated,
    EmptyField,
    InvalidDate,
    Error,
    Warning,
}

fn load_reminders() -> Vec<Reminder> {
    let data = fs::read_to_string(get_file_path()).unwrap_or_else(|_| "[]".to_string());
    serde_json::from_str(&data).unwrap_or_else(|_| Vec::new())

}
// ---CLI display struct ----- 
struct CliDsp {
    steps: i8,
    current_step: i8,
    field_buffer: Vec<String>,
    content_dsp: fn(i8),
    content_input: Option<fn(&mut Vec<String>, i8) -> STATUS>,
    validator: Option<fn(STATUS, &mut i8) -> STATUS>,
    callback: Option<fn(&Vec<String>)>,
}
 
// --- Funciones para CliDsp ---- 
//
// Validator:
fn validator(status: STATUS, current_step: &mut i8) -> STATUS {


    match status {
        STATUS::Good => {
            *current_step += 1;
            return STATUS::Good;
        },
        STATUS::AutoGenerated => {
            println!("Warnin: Auto-generated field");
            *current_step += 1;
            return STATUS::Warning;
        },
        STATUS::EmptyField => {
            println!("Error: This field cannot be empty.");
            return STATUS::Error;
        },
        STATUS::InvalidDate => {
            println!("Error: Invalid date format. Please enter the date in YYYY-MM-DD format.");
            return STATUS::Error;
        },
        _ => {
            println!("An unexpected error occurred.");
            return STATUS::Error;
        }

    }
}
// Add Reminder:
fn content_dsp_add_reminder(current_step: i8) {
    println!("Add Reminder");
        match current_step {
            0 => println!("Enter the name of the reminder:"),
            1 => println!("Enter an Alert Message:"),
            2 => println!("Enter the date of the reminder (YYYY-MM-DD):"),
            _ => println!("Invalid step"),
        }
}

fn content_input_add_reminder(field_buffer: &mut Vec<String>, current_step: i8) -> STATUS {
    let mut buffer = String::new();
    std::io::stdin().read_line(&mut buffer).expect("Failed to read line");
    let input = buffer.trim().to_string();


        match current_step {
            0 => {
             if input.is_empty() {
                return STATUS::EmptyField;
             } else {
                field_buffer.push(input);
                return STATUS::Good;
             }
            }
            1 => {
                if input.is_empty() {
                    field_buffer.push("-".to_string());
                    return STATUS::AutoGenerated;
                } else {
                    field_buffer.push(input);
                    return STATUS::Good;
                }
            }
            2 => {
                match NaiveDate::parse_from_str(&input, "%Y-%m-%d") {
                    Ok(_) => {
                        field_buffer.push(input);
                        return STATUS::Good;
                    },
                    Err(_) => {
                        return STATUS::InvalidDate;
                    }
                }
            }
            _ => {
                return STATUS::Error;
            }
        }
 }

fn callback_add_reminder(field_buffer: &Vec<String>) {
    
    println!("Saving reminder...");
    let reminder = Reminder {
        name: field_buffer[0].clone(),
        description: field_buffer[1].clone(),
        date: field_buffer[2].clone(),
    };

    let mut reminders = load_reminders();
    reminders.push(reminder);
    let data = serde_json::to_string_pretty(&reminders).expect("Failed to serialize reminders");
    fs::write(get_file_path(), data).expect("Failed to write reminders to file");

    println!("Reminder saved successfully!");
}

// ----- Show Reminders ----- 
fn content_dsp_show_reminders(_current_step: i8) {
    println!("       Rm |              Name               | Date       ");
    println!("       ---------------------------------------------");
    let reminders = load_reminders();
    if reminders.is_empty() {
        println!("Nothing here!.");
    } else {
        for (index, reminder) in reminders.iter().enumerate() {
            //TODO: Some magin numbers here!
            println!("       {:<2} | {:<35} | {:<10}",index+1, reminder.name, reminder.date);
        }
    }
}



#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    Add,
    Show,
    Rm { nombre: Option<String>,
        #[arg(long)]
        all: bool,
    },
    Edit { nombre: String},
    Check,

}

fn cli_clear_screen() {
    // Clear the screen using ANSI escape codes
    print!("\x1B[2J\x1B[1;1H");
}
fn display(feature: &mut CliDsp) {
    let mut status_dsp = STATUS::Good;         // Good by default.
    while feature.current_step < feature.steps {
        if status_dsp == STATUS::Good || status_dsp == STATUS::AutoGenerated {
            cli_clear_screen();
            println!("{}", CLI_TOP_BORDER);
        }
        (feature.content_dsp)(feature.current_step);
        println!("{}", CLI_BOTTOM_BORDER);
        if let Some(input_fn) = feature.content_input {
            if let Some(validator_fn) = feature.validator {
                status_dsp = (validator_fn)(input_fn(&mut feature.field_buffer, feature.current_step), &mut feature.current_step);
            }    
        } else {
            feature.current_step += 1; // If no input is needed, just move to the next step.
        }

    }
    if let Some(callback_fn) = feature.callback {                           // Just if needed a
                                                                            // final callback.
        callback_fn(&feature.field_buffer);
    }                                                                       
 }

fn main() {
    let cli = Cli::parse();

    match &cli.command {
        Some(Commands::Add) => {
            let mut add_reminder_dsp = CliDsp {
                steps: 3,
                current_step: 0,
                field_buffer: Vec::new(),
                content_dsp: content_dsp_add_reminder,
                content_input: Some(content_input_add_reminder),
                validator: Some(validator),
                callback: Some(callback_add_reminder),
            };
            display(&mut add_reminder_dsp);
                        // AquÃ­ puedes agregar la lÃ³gica para agregar una tarea
        }
        Some(Commands::Show) => {
            let mut show_reminders_dsp = CliDsp {
                steps: 1,
                current_step: 0,
                field_buffer: Vec::new(),
                content_dsp: content_dsp_show_reminders,
                content_input: None,
                validator: None,
                callback: None,
            };
            display(&mut show_reminders_dsp);
        }
        Some(Commands::Rm { nombre, all }) => {
            if *all {
                println!("Eliminando todas las tareas...");
                // AquÃ­ puedes agregar la lÃ³gica para eliminar todas las tareas
            } else if let Some(nombre) = nombre {
                println!("Eliminando tarea: {}", nombre);
                // AquÃ­ puedes agregar la lÃ³gica para eliminar una tarea especÃ­fica
            } else {
                println!("Por favor, especifica el nombre de la tarea o usa --all para eliminar todas las tareas.");
            }
        }
        Some(Commands::Edit { nombre }) => {
            println!("Editando tarea: {}", nombre);
            // AquÃ­ puedes agregar la lÃ³gica para editar una tarea especÃ­fica
        }
        Some(Commands::Check) => {
            run_check();
        }
        None => {
            println!("Usage: rem [action] --[option] 
actions: 
        add: Add new reminder.
        show: Show existent reminders.
        rm: Remove a specific reminder.(--all removes all reminders)
        edit: Edit a specific reminder (--id selects the reminder by its id)
                                       (--name selects the reminder by its name)"
                    );
        }
    }
   }
